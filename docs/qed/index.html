<html>
<head>
  <title>Hashery</title>

  <!-- TODO: most of the css before the '*' can be removed. -->

  <style>
    #container{ margin: 0 auto; width: 800px; }

    /* Debug borders */
    /* p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 { border: 1px solid red; } */

    body { font-size: 14px; line-height: 20px; margin: 1em 5% 1em 5%; font-family: Verdana, Arial, Helvetica, sans-serif; }
    a { color: #336; text-decoration: underline; }
    a:visited { color: #334; }
    em { font-style: italic; }
    strong { font-weight: bold; }
    tt { color: navy; }

    h1, h2, h3, h4, h5, h6 { color: #223; margin-top: 1.2em; margin-bottom: 0.5em; line-height: 1.3; }
    h1 { border-bottom: 2px solid silver; }
    h2 { border-bottom: 2px solid silver; padding-top: 0.5em; }

    hr { color: #ccc; margin-top: 1.6em; }

    p { color: #222; text-align: justify; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.4em; }

    /* pre { padding: 10; margin: 0; font-family: monospace; font-size: 0.9em; } */

    pre.pass { color: green; }
    pre.fail { color: red; }
    pre.error { color: red; font-weight: bold; }

    span#author { color: #527bbd; font-weight: bold; font-size: 1.1em; }
    span#email { }
    span#revision { }

    div#footer { font-size: small; border-top: 2px solid silver; padding-top: 0.5em; margin-top: 4.0em; }
    div#footer-text { float: left; padding-bottom: 0.5em; }
    div#footer-badges { float: right; padding-bottom: 0.5em; }

    /* Block element content. */
    div.content { padding: 0; }

    /* Block element titles. */
    h1.title { font-weight: bold; text-align: left; font-size: 3em; margin-top: 1.0em; margin-bottom: 0.5em; }

    /* Block element titles. */
    div.title, caption.title { font-weight: bold; text-align: left; margin-top: 1.0em; margin-bottom: 0.5em; }
    div.title + * { margin-top: 0; }
    td div.title:first-child { margin-top: 0.0em; }
    div.content div.title:first-child { margin-top: 0.0em; }
    div.content + div.title { margin-top: 0.0em; }
    div.sidebarblock > div.content { background: #ffffee; border: 1px solid silver; padding: 0.5em; }

    img { border-style: none; }

    dl { margin-top: 0.8em; margin-bottom: 0.8em; }
    dt { margin-top: 0.5em; margin-bottom: 0; font-style: italic; }
    dd > *:first-child { margin-top: 0; }
    ul, ol { list-style-position: outside; }

    thead { font-weight: bold; }
    tfoot { font-weight: bold; }

    *{margin:0;padding:0;}
    html,body{height:100%;color:black;}
    body{background-color:white;font:13.34px helvetica,arial,freesans,clean,sans-serif;*font-size:small;}
    table{font-size:inherit;font:100%;}
    select,input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}
    select,option{padding:0 .25em;}
    optgroup{margin-top:.5em;}
    input.text{padding:1px 0;}
    pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}
    body *{line-height:1.4em;}
    p{margin:1em 0;}
    img{border:0;}
    abbr{border-bottom:none;}

    .wikistyle h1,.wikistyle h2,.wikistyle h3,.wikistyle h4,.wikistyle h5,.wikistyle h6{border:0!important;}
    .wikistyle h1{font-size:170%!important;border-top:4px solid #aaa!important;padding-top:.5em!important;margin-top:1.5em!important;}
    .wikistyle h1:first-child{margin-top:0!important;padding-top:.25em!important;border-top:none!important;}
    .wikistyle h2{font-size:150%!important;margin-top:1.5em!important;border-top:4px solid #e0e0e0!important;padding-top:.5em!important;}
    .wikistyle h3{margin-top:1em!important;}
    .wikistyle p{margin:1em 0!important;line-height:1.5em!important;}
    .wikistyle ul{margin:1em 0 1em 2em!important;}
    .wikistyle ol{margin:1em 0 1em 2em!important;}
    .wikistyle ul ul,.wikistyle ul ol,.wikistyle ol ol,.wikistyle ol ul{margin-top:0!important;margin-bottom:0!important;}
    .wikistyle blockquote{margin:1em 0!important;border-left:5px solid #ddd!important;padding-left:.6em!important;color:#555!important;}
    .wikistyle dt{font-weight:bold!important;margin-left:1em!important;}
    .wikistyle dd{margin-left:2em!important;margin-bottom:1em!important;}
    .wikistyle table{margin:1em 0!important;}
    .wikistyle table th{border-bottom:1px solid #bbb!important;padding:.2em 1em!important;}
    .wikistyle table td{border-bottom:1px solid #ddd!important;padding:.2em 1em!important;}
    .wikistyle pre{margin:1em 0!important;font-size:90%!important;background-color:#f8f8ff!important;border:1px solid #dedede!important;padding:.5em!important;line-height:1.5em!important;color:#444!important;overflow:auto!important;}
    .wikistyle pre code{padding:0!important;font-size:100%!important;background-color:#f8f8ff!important;border:none!important;}
    .wikistyle code{font-size:90%!important;background-color:#f8f8ff!important;color:#444!important;padding:0 .2em!important;border:1px solid #dedede!important;}
    .wikistyle pre.console{margin:1em 0!important;font-size:90%!important;background-color:black!important;padding:.5em!important;line-height:1.5em!important;color:white!important;}
    .wikistyle pre.console code{padding:0!important;font-size:100%!important;background-color:black!important;border:none!important;color:white!important;}
    .wikistyle pre.console span{color:#888!important;}
    .wikistyle pre.console span.command{color:yellow!important;}

    .title { font-size: 2em; }
  </style>

  <!-- TODO: only include if these files exists -->
  <link href="../assets/styles/spec.css" type="text/css" rel="stylesheet">
  <!-- spec.css might be a problem with clobber -->
  <link href="spec.css" type="text/css" rel="stylesheet">

  

  <!-- JQuery is needed -->
  <script src="jquery.js" type="text/javascript" language="javascript"></script>

</head>

<body class="wikistyle">

  <!-- Side Table of Contents -->
  <div id="sidebar" style="position: fixed; top: 10; right: 10; background: white;">
    <a href="javascript: toc_toggle();">
      <img src="img/icon/book.jpg" height="30px;" style="border: none;" alt="TOC" align="right"/>
    </a>

    <div id="toc_side" class="toc">
    </div>
  </div>

  <div id="container">
    <div id="header">
      <img src="img/icon/book.jpg" align="left" style="padding-right: 10px;" alt=""/>

      <div class="title">Hashery</div>

      <h1>Table of Contents</h1>

      <div class="toc">
      </div>
    </div>

    <div id="content">
      <h1>OpenHash</h1>
<p>
An OpenHash is a Hash that provides <tt>open</tt> access to its entries via
method calls. Writers (methods ending in =-marks) assign entries. Methods
without special puncuation will retrieve entries. 
</p>
<pre>
  require 'hashery/openhash'

  o = OpenHash.new
  o.a = 1
  o.b = 2
  o.a.assert == 1
  o.b.assert == 2
</pre>
<p>
Writers always use a Symbol for keys in the underlying Hash.
</p>
<pre>
  o.to_h.assert == { :a=&gt;1, :b=&gt;2 }
</pre>
<p>
All the usual Hash methods are still available in an OpenHash.
</p>
<pre>
  o.map{ |k,v| [k,v] }
</pre>
<p>
And they are protected from being overridden by writers.
</p>
<pre>
  o.map = 3
  o.map{ |k,v| [k,v] }
</pre>
<p>
Even so, the underlying Hash object does contain the entry even  when it
can not be accessed via a reader method.
</p>
<pre>
  o.to_h.assert == {:a=&gt;1, :b=&gt;2, :map=&gt;3 }
</pre>
<p>
For some usecases it may be necessary to give up access to one or more Hash
methods in favor of access to the hash entries. This can be done using the
#omit! method.
</p>
<pre>
  o.omit!(:map, :merge)
  o.map.assert == 3
  o.merge = 4
  o.merge.assert == 4
</pre>
<p>
Becuase of nature of a writer, a certain set of Hash methods are always
protected, namely any of those ending in a puctuation mark. In addition,
the implementation protects all shadow methods (e.g. <em>id</em>).
</p>
<pre>
  o.__id__ = 4
  o.__id__.assert! == 4
</pre>
<p>
Even though writers alwasy use Symbols as keys, because an OpenHash is a
true Hash object, any object can be used as a key internally.
</p>
<pre>
  o = OpenHash.new
  o[nil] = &quot;Nothing&quot;
  o.to_h.assert == { nil=&gt;&quot;Nothing&quot; }
</pre>
<p>
It simply will not be accessible via a reader method.
</p>

<h1>QueryHash</h1>
<p>
A QueryHash is a Hash that provides open access much like an OpenHash, but
it limits readers to query methods (i.e. method ending in ?-marks).
</p>
<pre>
  require 'hashery/queryhash'

  q = QueryHash.new
  q.a = 1
  q.b = 2
  q.a?.assert == 1
  q.b?.assert == 2
</pre>
<p>
Writers always use Symbols for entry keys.
</p>
<pre>
  q.assert == { :a=&gt;1, :b=&gt;2 }
</pre>
<p>
A QueryHash is compatible with Ruby&#8217;s standard Hash in every other
respect.
</p>

<h1>CastingHash</h1>
<p>
A CastingHash is a Hash that allows <em>casting</em> procedures to defined
that the keys and values pass through upon assignment.
</p>
<pre>
  require 'hashery/castinghash'

  c = CastingHash.new{ |x| x.to_s }

  c[:a] = 1

  c.assert == {'a'=&gt;1}
</pre>

<h1>StaticHash</h1>
<p>
A StaticHash is simply a Hash that can only be assigned once per key. Once
assigned a subsequent attempt to assign a value to the same key will raise
an ArgumentError.
</p>
<pre>
  require 'hashery/statichash'

  h = StaticHash.new

  h[&quot;x&quot;] = 1

  expect ArgumentError do
    h[&quot;x&quot;] = 2
  end
</pre>
<p>
The same error will be raised when using #update or #merge!.
</p>
<pre>
  expect ArgumentError do
    h.update( :x=&gt;2 )
  end
</pre>

<h1>Association</h1>
<p>
An Association is a class for creating simple pairings.
</p>
<pre>
    require 'hashery/association'
</pre>
<p>
An Association can bew created through the usual means  of instantiation.
</p>
<pre>
    Association.new(:a, :b)
</pre>
<p>
Or the shortcut method #>> can be used in most cases.
</p>
<pre>
    :x &gt;&gt; :z
</pre>
<p>
An association provides two methods to access its content, #index and
#value.
</p>
<pre>
    a = 'foo' &gt;&gt; 'bar'

    a.index.assert == 'foo'
    a.value.assert == 'bar'
</pre>
<p>
Associations can be used to create ordered-hashes via normal arrays.
</p>
<pre>
    keys = []
    vals = []

    ohash = [ 'A' &gt;&gt; '3', 'B' &gt;&gt; '2', 'C' &gt;&gt; '1' ]

    ohash.each{ |k,v| keys &lt;&lt; k ; vals &lt;&lt; v }

    keys.assert == ['A','B','C']
    vals.assert == ['3','2','1']
</pre>
<p>
Becuase Associations are objects in themselves more complex collections can
also be created.
</p>
<pre>
    complex = [
      'parent' &gt;&gt; 'child',
      'childless',
      'another_parent' &gt;&gt; [
        'subchildless',
        'subparent' &gt;&gt; 'subchild'
      ]
    ]
</pre>
<p>
An experimental feature of Association keeps a cache of all defined
associations.
</p>
<pre>
    o = Object.new
    o &gt;&gt; :a
    o &gt;&gt; :b
    o &gt;&gt; :c

    o.associations.assert == [:a, :b, :c]
</pre>
<p>
However this feature will probably be deprecated.
</p>

<h1>OpenCascade</h1>
<p>
OpenCascade is subclass of OpenObject. It differs in a few significant
ways.
</p>
<pre>
   require 'hashery/opencascade'
</pre>
<p>
The main reason this class is labeled &#8220;cascade&#8221;, every internal
Hash is transformed into an OpenCascade dynamically upon access. This makes
it easy to create &#8220;cascading&#8221; references.
</p>
<pre>
    h = { :x =&gt; { :y =&gt; { :z =&gt; 1 } } }
    c = OpenCascade[h]
    c.x.y.z.assert == 1
</pre>
<p>
As soon as you access a node it automatically becomes an OpenCascade.
</p>
<pre>
    c = OpenCascade.new
    c.r.assert.is_a? OpenCascade
    c.a.b.assert.is_a? OpenCascade
</pre>
<p>
But if you set a node, then that will be it&#8217;s value.
</p>
<pre>
    c.a.b = 4
    c.a.b.assert == 4
</pre>
<p>
To query a node without causing the auto-creation of an OpenCasade object,
use the ?-mark.
</p>
<pre>
   c.a.z?.assert == nil
</pre>
<p>
OpenCascade also transforms Hashes within Arrays.
</p>
<pre>
  h = { :x=&gt;[ {:a=&gt;1}, {:a=&gt;2} ], :y=&gt;1 }
  c = OpenCascade[h]
  c.x.first.a.assert == 1
  c.x.last.a.assert == 2
</pre>
<p>
Like OpenObject, OpenCascade allows you to insert entries as array pairs.
</p>
<pre>
   c = OpenCascade.new
   c &lt;&lt; [:x,8]
   c &lt;&lt; [:y,9]

   c.x.assert == 8
   c.y.assert == 9
</pre>
<p>
Finally, you can call methods ending in a !-mark to access the underlying
hash (Note that these differ in behavior from the built-in !-methods).
</p>
<pre>
   bk = c.map!{ |k,v| k.to_s.upcase }
   bk.sort.assert ==  ['X', 'Y']
</pre>
<p>
So you can see that for the most an OpenCascade is just like OpenObject,
but it allows you to conveniently build open sub-layers. 
</p>

<h1>FuzzyHash</h1>
<p>
Require the library.
</p>
<pre>
    require 'hashery/fuzzyhash'
</pre>
<p>
Should accept strings and retrieve based on them.
</p>
<pre>
    l = FuzzyHash.new
    l['asd'] = 'qwe'
    l['asd'].should == 'qwe'
  
</pre>
<p>
Should accept strings, but the second time you set the same string, it
should overwrite.
</p>
<pre>
    l = FuzzyHash.new
    l['asd'] = 'asd'
    l['asd'] = 'qwe'
    l['asd'].should == 'qwe'
</pre>
<p>
Should accept regexs too.
</p>
<pre>
    l = FuzzyHash.new
    l[/asd.*/] = 'qwe'
    l['asdqweasd'].should == 'qwe'
</pre>
<p>
Should accept regexs too, but the second time you set the same regex, it
should overwrite.
</p>
<pre>
    l = FuzzyHash.new
    l[/asd/] = 'asd'
    l[/asd/] = 'qwe'
    l['asdqweasd'].should == 'qwe'
</pre>
<p>
Should accept regexs too with the match.
</p>
<pre>
    l = FuzzyHash.new
    l[/asd.*/] = 'qwe'
    l.match_with_result('asdqweasd').should == ['qwe', 'asdqweasd']
</pre>
<p>
Should accept regexs that match the whole strong too with the match.
</p>
<pre>
    l = FuzzyHash.new
    l[/asd/] = 'qwe'
    l.match_with_result('asd').should == ['qwe', 'asd']
</pre>
<p>
Should prefer string to regex matches.
</p>
<pre>
    l = FuzzyHash.new
    l['asd'] = 'qwe2'
    l[/asd.*/] = 'qwe'
    l['asd'].should == 'qwe2'
</pre>
<p>
Should allow nil keys.
</p>
<pre>
    l = FuzzyHash.new
    l[nil] = 'qwe2'
    l['asd'] = 'qwe'
    l['asd'].should == 'qwe'
    l[nil].should == 'qwe2'
</pre>
<p>
Should allow boolean keys.
</p>
<pre>
    l = FuzzyHash.new
    l[false] = 'false'
    l[true] = 'true'
    l[/.*/] = 'everything else'
    l[true].should == 'true'
    l[false].should == 'false'
    l['false'].should == 'everything else'
</pre>
<p>
Should pick between the correct regex.
</p>
<pre>
    hash = FuzzyHash.new
    hash[/^\d+$/] = 'number'
    hash[/.*/] = 'something'
    hash['123asd'].should == 'something'
</pre>
<p>
Should be able to delete by value for hash.
</p>
<pre>
    l = FuzzyHash.new
    l[nil] = 'qwe2'
    l['asd'] = 'qwe'
    l['asd'].should == 'qwe'
    l[nil].should == 'qwe2'
    l.delete_value('qwe2')
    l[nil].should == nil
</pre>
<p>
Should be able to delete by value for regex.
</p>
<pre>
    l = FuzzyHash.new
    l[/qwe.*/] = 'qwe2'
    l['asd'] = 'qwe'
    l['asd'].should == 'qwe'
    l['qweasd'].should == 'qwe2'
    l.delete_value('qwe2')
    l['qweasd'].should == nil
</pre>
<p>
Should iterate through the keys.
</p>
<pre>
    l = FuzzyHash.new
    l[/qwe.*/] = 'qwe2'
    l['asd'] = 'qwe'
    l['zxc'] = 'qwe'
    l.keys.size.should == 3
</pre>
<p>
Should iterate through the values.
</p>
<pre>
    l = FuzzyHash.new
    l[/qwe.*/] = 'qwe2'
    l['asd'] = 'qwe'
    l['zxc'] = 'qwelkj'
    (['qwe2','qwe','qwelkj'] &amp; l.values).size.should == 3
</pre>
<p>
Should clear.
</p>
<pre>
    l = FuzzyHash.new
    l[/qwe.*/] = 'qwe2'
    l['asd'] = 'qwe'
    l['zxc'] = 'qwelkj'
    l.clear
    l.empty?.should == true
 
</pre>
<p>
Should handle equality.
</p>
<pre>
    l_1 = FuzzyHash.new
    l_1[/qwe.*/] = 'qwe2'
    l_1['asd'] = 'qwelkj'
    l_1['zxc'] = 'qwe'
    l_2 = FuzzyHash.new
    l_2['zxc'] = 'qwe'
    l_2['asd'] = 'qwelkj'
    l_2[/qwe.*/] = 'qwe2'
    l_1.should == l_2
</pre>
<p>
Should return the value when adding the value.
</p>
<pre>
    h = FuzzyHash.new
    (h[/asd/] = '123').should == '123'
    (h['qwe'] = '123').should == '123'
</pre>
<p>
That&#8217;s It.
</p>

<h1>PropertyHash</h1>
<p>
Require the library.
</p>
<pre>
    require 'hashery/propertyhash'
</pre>
<p>
The Property hash can be used an object in itself.
</p>
<pre>
     h = PropertyHash.new(:a=&gt;1, :b=&gt;2)
     h[:a]        #=&gt; 1
     h[:a] = 3
     h[:a]        #=&gt; 3
</pre>
<p>
Becuase the properties are fixed, if we try to set a key that is not
present, then we will get an error.
</p>
<pre>
    expect ArgumentError do
      h[:x] = 5
    end
</pre>
<p>
The PropertyHash can also be used as a superclass.
</p>
<pre>
    class MyPropertyHash &lt; PropertyHash
      property :a, :default =&gt; 1
      property :b, :default =&gt; 2
    end

    h = MyPropertyHash.new
    h[:a]        #=&gt; 1
    h[:a] = 3
    h[:a]        #=&gt; 3
</pre>
<p>
Again, if we try to set key that was not fixed, then we will get an error.
</p>
<pre>
    expect ArgumentError do
      h[:x] = 5
    end
</pre>


    </div>
  </div>

  <br/><br/><br/>
</body>

</html>

<script src="../assets/scripts/spec.js" type="text/javascript" language="javascript"></script>

<script type="text/javascript" language="javascript">
  /*****************************************************************
   * $.toc()
   * by rebecca murphey
   * rmurphey gmail com
   *
   * This function is called on its own and takes as an argument
   * a list of selectors with which it will build a table of
   * contents. 
   *
   * The first selector will make up the top level of the TOC;
   * the second selector will make up the second level of the TOC;
   * etc.
   *
   * This function returns a div containing nested unordered lists;
   * each list item is linked to an anchor tag added before the item
   * on the page.
   *
   * usage: $.toc('h1,h2,h3').prependTo('body');
   ************************************************************************/
  (function($) { 
    $.toc = function(tocList) {
      $(tocList).addClass('jquery-toc');
      var tocListArray = tocList.split(',');
      $.each(tocListArray, function(i,v) { tocListArray[i] = $.trim(v); });
      var $elements = $('.jquery-toc');
      $('body').append('<div></div>');
      var $toc = $('body div:last');
      var lastLevel = 1;
      $toc.append('<ul class="jquery-toc-1"></ul>');
      $elements.each(function() {
        var $e = $(this);
        var text = $e.text();
        var anchor = text.replace(/ /g,'-');
        $e.before('<a name="' + anchor + '"></a>');
        var level;
        $.each(tocListArray, function(i,v) { 
          if (v.match(' ')) {
            var vArray = v.split(' '); 
            var e = vArray[vArray.length - 1];
          } else { e = v; }
          if ($e.is(e)) { level = i+1; } 
        });
        var className = 'jquery-toc-' + level;
        var li = '<li><a href="#' + anchor + '">' + text + '</a></li>';
        if (level == lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level > lastLevel) {
          var parentLevel = level - 1;
          var parentClassName = 'jquery-toc-' + parentLevel;
          $('ul.' + parentClassName + ':last',$toc).
            append('<ul class="' + className + '"></ul>');
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level < lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        }
        lastLevel = level;
      });
      var $toc_ul = $('ul.jquery-toc-1',$toc);
      $toc.remove();
      return($toc_ul);
   }
  })(jQuery);
</script>

<script>
  function toc_toggle() {
    $('#toc_side').toggle();
    $("pre").addClass("pass");
    $("pre:contains('FAIL:')").addClass("fail");
    $("pre:contains('ERROR:')").addClass("error");
  };

  $.toc('#content h1,h2,h3,h4').appendTo('.toc');

  toc_toggle();
</script>

